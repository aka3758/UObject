# 类型系统代码生成

## 引言

概念上分为以下几个阶段：生成，收集，注册，链接。

在生成阶段，UHT分析我们的代码，并生成类型系统的相关代码。

### Note1

生成的代码和注册的过程会因为HotReload功能的开启与否有些不一样，因此为了最简化流程阐述，我们先关闭HotReload，关闭的方式是在Hello.Build.cs里加上一行：PublicDefinitions.Add("WITH_HOT_RELOAD_CTORS=0");

## C++ Static Lazy初始化模式

一种我们常用，也是UE中常用的单件懒惰初始化模式是:

```C++
Hello* StaticGetHello()
{
    static Hello* obj=nullptr;
    if(!obj)
    {
        obj=...
    }
    return obj;
}
或者
Hello& StaticGetHello()
{
    static Hello obj(...);
    return obj;
}
```

前者非常简单，也没考虑多线程安全，但是在单线程环境下足够用了。用指针的原因是，有一些情况，这些对象的生命周期是由别的地方来管理的，比如UE里的GC，因此这里只static化一个指针。否则的话，还是后者更加简洁和安全。

## UHT代码生成

只要是采用了宏标记的方法，不管是怎么个标记语法，我们都需要进行简单或复杂的词法分析，提取出有用的信息，然后生成所需要的代码。在引擎里创建一个空C++项目命名为Hello，然后创建个不继承的MyClass类。编译，UHT就会为我们生成以下4个文件（位于Hello\Intermediate\Build\Win64\UnrealEditor\Inc\Hello）

* HelloClasses.h：目前无用
* MyClass.generated.h：MyClass的生成头文件
* Hello.gen.h：Hello.generated.cpp的依赖头文件，也就是顺序包含上述的MyClass.h而已
* Hello.init.gen.cpp：该项目的实现编译单元。

看起来很多很复杂，但其实比较简单，不过就是一些宏替换而已。

生成的函数大都也以Z_开头，没什么特别含义，就是简单为了避免命名冲突，用Z是为了字母排序总是出现在智能感知的最下面，尽量隐藏起来。

## UCLASS的生成代码剖析

先从一个最简单的UMyClass的开始，总览分析生成的代码结构，接着再继而观察其他UEnum、UStruct、UInterface、UProperty、UFunction的代码生成样式。

### MyClass.h

```C++
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "MyClass.generated.h"

UCLASS()
class HELLO_API UMyClass : public UObject
{
    GENERATED_BODY()
};
```

* #include "UObject/NoExportTypes.h" 通过查看文件内容，发现这个文件在编译的时候就是包含了其他一些更基础的头文件，比如一些数学矩阵库等，因此你才能在MyClass里不用include就引用这些类。还有一些内容是专门供UHT使用来生成蓝图类型的，现在暂时不需要管。
* #include "MyClass.generated.h"，就是为了**引用**生成的头文件。这里请注意的是，该文件include位于**所有头文件的最后面**，之后谈到宏处理的时候会用到该信息。
* GENERATED_BODY()，该宏是重中之重，其他的UCLASS宏只是提供信息，不参与编译，而GENERATED_BODY正是**把声明和元数据定义关联到一起**的枢纽。

查看GENERATED_BODY()宏定义：

```C++
#define BODY_MACRO_COMBINE_INNER(A,B,C,D) A##B##C##D
#define BODY_MACRO_COMBINE(A,B,C,D) BODY_MACRO_COMBINE_INNER(A,B,C,D)
#define GENERATED_BODY(...) BODY_MACRO_COMBINE(CURRENT_FILE_ID,_,__LINE__,_GENERATED_BODY)
```

GENERATED_BODY宏最终其实只是生成另外一个宏的名称，因为：

CURRENT_FILE_ID的定义是在MyClass.generated.h的89行：\#define CURRENT_FILE_ID Hello_Source_Hello_MyClass_h，这是UHT通过分析文件得到的信息。

__LINE__标准宏指向了该宏使用时候的的函数，其实就是宏所在的**行号**。加了一个__LINE__宏的目的是为了**支持在同一个文件内声明多个类**，比如在MyClass.h里接着再声明UMyClass2，就可以支持生成不同的宏名称。

因此生成的宏名称是FID_Hello_Source_Hello_MyClass_h_15_GENERATED_BODY，而这个宏就是定义在MyClass.generated.h的75行。

如果MyClass类需要UMyClass(const FObjectInitializer& ObjectInitializer)的构造函数自定义实现，则需要用GENERATED_BODY_LEGACY宏来让最终生成的宏指向FID_Hello_Source_Hello_MyClass_h_15_GENERATED_BODY_LEGACY（MyClass.generated.h的63行），其最终展开的内容会多一个构造函数的内容实现。

## MyClass.generated.h

从下往上看

两个GENERATED_BODY宏(还有一个带有LEGACY)包含了4个声明在上面的其他宏。

目前来说FID_Hello_Source_Hello_MyClass_h_15_INCLASS_NO_PURE_DECLS宏和FID_Hello_Source_Hello_MyClass_h_15_INCLASS宏的定义一摸一样。

FID_Hello_Source_Hello_MyClass_h_15_STANDARD_CONSTRUCTORS宏和FID_Hello_Source_Hello_MyClass_h_15_ENHANCED_CONSTRUCTORS宏，二者的差别只是enhanced(增强的)有了构造函数的默认实现：

```C++
    NO_API UMyClass(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get()) : Super(ObjectInitializer) { }; \
```

这里有一个细节，把C++11的移动构造(右值引用)和拷贝构造(const引用)设为私有，把它们**禁止**了：

```C++
private: \
    /** Private move- and copy-constructors, should never be used */ \
    NO_API UMyClass(UMyClass&&); \
    NO_API UMyClass(const UMyClass&); \
```

继续往上看，FID_Hello_Source_Hello_MyClass_h_15_ENHANCED_CONSTRUCTORS宏

```C++
#define FID_Hello_Source_Hello_MyClass_h_15_ENHANCED_CONSTRUCTORS \
    /** Standard constructor, called after all reflected properties have been initialized */ \
    NO_API UMyClass(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get()) : Super(ObjectInitializer) { }; \
private: \  //禁止C++的移动构造和拷贝构造
    /** Private move- and copy-constructors, should never be used */ \
    NO_API UMyClass(UMyClass&&); \
    NO_API UMyClass(const UMyClass&); \
public: \
    DECLARE_VTABLE_PTR_HELPER_CTOR(NO_API, UMyClass); \
    DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(UMyClass); \
    DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL(UMyClass)
```

查看DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL(定义默认对象初始化构造函数调用
)宏的定义，虚幻的源码里，不在生成的.h和.cpp中：

```C++
#define DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL(TClass) \
    static void __DefaultConstructor(const FObjectInitializer& X) { new((EInternal*)X.GetObj())TClass(X); }
```

这是一个静态函数。这么做的原因是，在根据名字反射创建对象的时候，**需要调用该类的构造函数**。可是类的**构造函数并不能用函数指针指向**。用一个static函数包装一下，静态函数属于类空间，而且所有类的签名一致，就可以**在UClass里用一个函数指针里保存起来**。这样构造对象的时候就可以调用这个函数指针去构建。见引擎里Class.h的声明：

```C++
class COREUOBJECT_API UClass : public UStruct
{
    typedef void (*ClassConstructorType) (const FObjectInitializer&);   //一个函数指针类型的定义
    ClassConstructorType ClassConstructor;  //函数指针成员变量
}
```

如果是自己的反射框架，类似功能采用模板来实现也是可以的，比如：

```C++
template<class TClass>
void MyConstructor( const FObjectInitializer& X )
{ 
    new((EInternal*)X.GetObj())TClass(X);
}
```

再往上，就是FID_Hello_Source_Hello_MyClass_h_15_INCLASS宏定义：

```C++
#define FID_Hello_Source_Hello_MyClass_h_15_INCLASS \
private: \
    static void StaticRegisterNativesUMyClass(); \
    friend struct Z_Construct_UClass_UMyClass_Statics; \
public: \
    //类声明
    DECLARE_CLASS(UMyClass, UObject, COMPILED_IN_FLAGS(0), CASTCLASS_None, TEXT("/Script/Hello"), NO_API) \
    //序列化声明
    DECLARE_SERIALIZER(UMyClass)
```

DECLARE_CLASS宏是最重要的一个声明，对照源码宏定义：

```C++
#define DECLARE_CLASS( TClass, TSuperClass, TStaticFlags, TStaticCastFlags, TPackage, TRequiredAPI  ) \
private: \
    TClass& operator=(TClass&&);   \
    TClass& operator=(const TClass&);   \
    TRequiredAPI static UClass* GetPrivateStaticClass(); \
public: \
    /** Bitwise union of #EClassFlags pertaining to this class.*/ \
    enum {StaticClassFlags=TStaticFlags}; \
    /** Typedef for the base class ({{ typedef-type }}) */ \
    typedef TSuperClass Super;\
    /** Typedef for {{ typedef-type }}. */ \
    typedef TClass ThisClass;\
    /** Returns a UClass object representing this class at runtime */ \
    /** 在运行时，返回代表这个类的UClass对象 */ \
    inline static UClass* StaticClass() \
    { \
        return GetPrivateStaticClass(); \
    } \
    /** Returns the package this class belongs in */ \
    /** 返回此类所属的包 */
    inline static const TCHAR* StaticPackage() \
    { \
        return TPackage; \
    } \
    /** Returns the static cast flags for this class */ \
    inline static EClassCastFlags StaticClassCastFlags() \
    { \
        return TStaticCastFlags; \
    } \
    /** For internal use only; use StaticConstructObject() to create new objects. */ \
    inline void* operator new(const size_t InSize, EInternal InInternalOnly, UObject* InOuter = (UObject*)GetTransientPackage(), FName InName = NAME_None, EObjectFlags InSetFlags = RF_NoFlags) \
    { \
        return StaticAllocateObject(StaticClass(), InOuter, InName, InSetFlags); \
    } \
    /** For internal use only; use StaticConstructObject() to create new objects. */ \
    inline void* operator new( const size_t InSize, EInternal* InMem ) \
    { \
        return (void*)InMem; \
    } \
    /* Eliminate V1062 warning from PVS-Studio while keeping MSVC and Clang happy. */ \
    inline void operator delete(void* InMem) \
    { \
        ::operator delete(InMem); \
    }
```

* TClass：类名
* TSuperClass：基类名字
* TStaticFlags：类的属性标记，这里是0，表示最默认，不带任何其他属性。读者可以查看EClassFlags枚举来查看其他定义。
* TStaticCastFlags：指定了该类可以转换为哪些类，这里为0表示不能转为那些默认的类，读者可以自己查看EClassCastFlags声明来查看具体有哪些默认类转换。
* TPackage：类所处于的包名，所有的对象都必须处于一个包中，而每个包都具有一个名字，可以通过该名字来查找。这里是"/Script/Hello"，指定是Script下的Hello，Script可以理解为用户自己的实现，不管是C++还是蓝图，都可以看作是引擎外的一种脚本，当然用这个名字也肯定有UE3时代UnrealScript的影子。Hello就是项目名字，该项目下定义的对象处于该包中。Package的概念涉及到后续Object的组织方式，目前可以简单理解为一个大的Object包含了其他子Object。
* TRequiredAPI：就是用来Dll导入导出的标记，这里是NO_API，因为最终是exe格式，不需要导出。

---

**Package**是什么

UE4中的Package是一个抽象的概念，一个Package是一个文件（.uasset或者.umap），它包含一些UE4可以进行操作和访问的二进制数据文件。一个对象所属于的UPackage，实际上是在物理内存上指出了这个对象被存放在哪里。想象一下，内存中有一片方形的区域，被划分给了PackageA，那么如果一个对象B的UPackage就是包A，就代表它被放在了这个“方形的区域中”。（先前我们说的父对象，更像是我们人为地去指定的，二者在内存区域中并不具有包含关系）当然，这样形象的说法只是为了帮助读者理解二者之间的关系，并不是很准确。

---

StaticClass是最经常用到的函数，其内部调用了GetPrivateStaticClass，而实现正是在Hello.generated.cpp里的。
