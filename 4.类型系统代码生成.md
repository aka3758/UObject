# 类型系统代码生成

## 引言

概念上分为以下几个阶段：生成，收集，注册，链接。

在生成阶段，UHT分析我们的代码，并生成类型系统的相关代码。

### Note1

生成的代码和注册的过程会因为HotReload功能的开启与否有些不一样，因此为了最简化流程阐述，我们先关闭HotReload，关闭的方式是在Hello.Build.cs里加上一行：PublicDefinitions.Add("WITH_HOT_RELOAD_CTORS=0");

## C++ Static Lazy初始化模式

一种我们常用，也是UE中常用的单件懒惰初始化模式是:

```C++
Hello* StaticGetHello()
{
    static Hello* obj=nullptr;
    if(!obj)
    {
        obj=...
    }
    return obj;
}
或者
Hello& StaticGetHello()
{
    static Hello obj(...);
    return obj;
}
```

前者非常简单，也没考虑多线程安全，但是在单线程环境下足够用了。用指针的原因是，有一些情况，这些对象的生命周期是由别的地方来管理的，比如UE里的GC，因此这里只static化一个指针。否则的话，还是后者更加简洁和安全。

## UHT代码生成

只要是采用了宏标记的方法，不管是怎么个标记语法，我们都需要进行简单或复杂的词法分析，提取出有用的信息，然后生成所需要的代码。在引擎里创建一个空C++项目命名为Hello，然后创建个不继承的MyClass类。编译，UHT就会为我们生成以下4个文件（位于Hello\Intermediate\Build\Win64\UnrealEditor\Inc\Hello）

* HelloClasses.h：目前无用
* MyClass.generated.h：MyClass的生成头文件
* Hello.gen.h：Hello.generated.cpp的依赖头文件，也就是顺序包含上述的MyClass.h而已
* Hello.init.gen.cpp：该项目的实现编译单元。

看起来很多很复杂，但其实比较简单，不过就是一些宏替换而已。

生成的函数大都也以Z_开头，没什么特别含义，就是简单为了避免命名冲突，用Z是为了字母排序总是出现在智能感知的最下面，尽量隐藏起来。

## UCLASS的生成代码剖析

先从一个最简单的UMyClass的开始，总览分析生成的代码结构，接着再继而观察其他UEnum、UStruct、UInterface、UProperty、UFunction的代码生成样式。

### MyClass.h

```C++
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "MyClass.generated.h"

UCLASS()
class HELLO_API UMyClass : public UObject
{
    GENERATED_BODY()
};
```

* #include "UObject/NoExportTypes.h" 通过查看文件内容，发现这个文件在编译的时候就是包含了其他一些更基础的头文件，比如一些数学矩阵库等，因此你才能在MyClass里不用include就引用这些类。还有一些内容是专门供UHT使用来生成蓝图类型的，现在暂时不需要管。
* #include "MyClass.generated.h"，就是为了**引用**生成的头文件。这里请注意的是，该文件include位于**所有头文件的最后面**，之后谈到宏处理的时候会用到该信息。
* GENERATED_BODY()，该宏是重中之重，其他的UCLASS宏只是提供信息，不参与编译，而GENERATED_BODY正是**把声明和元数据定义关联到一起**的枢纽。

查看GENERATED_BODY()宏定义：

```C++
#define BODY_MACRO_COMBINE_INNER(A,B,C,D) A##B##C##D
#define BODY_MACRO_COMBINE(A,B,C,D) BODY_MACRO_COMBINE_INNER(A,B,C,D)
#define GENERATED_BODY(...) BODY_MACRO_COMBINE(CURRENT_FILE_ID,_,__LINE__,_GENERATED_BODY)
```

GENERATED_BODY宏最终其实只是生成另外一个宏的名称，因为：

CURRENT_FILE_ID的定义是在MyClass.generated.h的89行：\#define CURRENT_FILE_ID Hello_Source_Hello_MyClass_h，这是UHT通过分析文件得到的信息。

__LINE__标准宏指向了该宏使用时候的的函数，其实就是宏所在的**行号**。加了一个__LINE__宏的目的是为了**支持在同一个文件内声明多个类**，比如在MyClass.h里接着再声明UMyClass2，就可以支持生成不同的宏名称。

因此生成的宏名称是FID_Hello_Source_Hello_MyClass_h_15_GENERATED_BODY，而这个宏就是定义在MyClass.generated.h的75行。

如果MyClass类需要UMyClass(const FObjectInitializer& ObjectInitializer)的构造函数自定义实现，则需要用GENERATED_BODY_LEGACY宏来让最终生成的宏指向FID_Hello_Source_Hello_MyClass_h_15_GENERATED_BODY_LEGACY（MyClass.generated.h的63行），其最终展开的内容会多一个构造函数的内容实现。

## MyClass.generated.h

从下往上看

两个GENERATED_BODY宏(还有一个带有LEGACY)包含了4个声明在上面的其他宏。

目前来说FID_Hello_Source_Hello_MyClass_h_15_INCLASS_NO_PURE_DECLS宏和FID_Hello_Source_Hello_MyClass_h_15_INCLASS宏的定义一摸一样。

FID_Hello_Source_Hello_MyClass_h_15_STANDARD_CONSTRUCTORS宏和FID_Hello_Source_Hello_MyClass_h_15_ENHANCED_CONSTRUCTORS宏，二者的差别只是enhanced(增强的)有了构造函数的默认实现：

```C++
    NO_API UMyClass(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get()) : Super(ObjectInitializer) { }; \
```

这里有一个细节，把C++11的移动构造(右值引用)和拷贝构造(const引用)设为私有，把它们**禁止**了：

```C++
private: \
    /** Private move- and copy-constructors, should never be used */ \
    NO_API UMyClass(UMyClass&&); \
    NO_API UMyClass(const UMyClass&); \
```
