# 类型系统概述

## 哪一个是Object系统必须的功能

反射。其他功能在有了反射之后都可以比较方便的实现，其他功能也要借助反射。

举个例子，反射里对每个object有个class对象保存信息，所以理论上class身上就可以保存所有该类型的object指针引用，这个信息GC就可以利用起来实现一些功能；而没有这个class对象的话，GC的实现就得走别的方案路子了。

## 类型系统

其实，反射只是在类型系统之后实现的附加功能。

### 实现了class类提供Object的类型信息，但是不提供动态创建，动态调用函数等功能，请问还有没有意义？

其实还仍然是非常有意义的，光光是提供了一个类型信息，就提供了一个Object之外的静态信息载体，也能构建起来object之间的派生从属关系，想想UE里如果去掉了根据名字创建类对象的能力，是会损失一些便利功能，但确实也还没有到元气大伤的程度，GC依然能跑得起来。

“类型系统”这个更精确的术语来表述object之外的类型信息构建。

“反射”这个术语来描述运行时得到类型的功能，通过类型信息反过来创建对象，读取修改属性，调用方法的功能行为。

反射更多是一种行为能力，更偏向动词。类型系统指的是程序运行空间内构建出来的类型信息树组织。

## C++ RTTI

C++中的运行时类型系统，指的是RTTI（Run-Time Type Identification），只提供了两个最基本的操作符：

### typeid

这个关键字的主要作用就是用于让用户知道是什么类型，并提供一些基本对比和name方法，作用也顶多只是让用户判断从属于不同的类型，所以其实说起来type_info的应用并不广泛，一般来说也只是把它当作编译器提供的一个唯一类型Id。

### dynamic_cast

该转换符用于将一个指向派生类的基类指针或引用转换为派生类的指针或引用，使用条件是只能用于含有虚函数的类。转换引用失败会抛出bad_cast异常，转换指针失败会返回null。

dynamic_cast内部机制其实也是利用虚函数表里的类型信息来判断一个基类指针是否指向一个派生类对象。其目的更多是用于在运行时判断对象指针是否为特定一个子类的对象。

## C++ 当前实现反射的方案

### 宏

基本思想是采用手动标记。在程序中用手动的方式注册各个类，方法，数据。

用宏偷梁换柱的把正常的声明换成自己的结构。简单可见这种方式还比较的原始，写起来也非常的繁琐。因此往往用的不多。更重要的是往往需要打破常规的书写方式，因此常常被摒弃掉。

### 模板

引导其强大的编译器类型识别能力构建出相应的数据结构，理论上也是可以实现出一定的类型系统。

需要一个个的手动去定义类并获取方法属性注册。优点是轻量程序内就能直接内嵌，缺点是不适合懒人。

### 编译器数据分析

分析VC编译生成后pdb文件，然后抽取出类型定义的信息实现反射。VC确实也提供了IDiaDataSource COM组件用来读取pdb文件的内容。

理论上来说，只要你能获取到跟编译器同级别的类型信息，你基本上就像是全知了。但是缺点是分析编译器的生成数据，太过依赖平台（比如只能VC编译，换了Clang就是另一套方案），分析提取的过程往往也比较麻烦艰深，在正常的编译前需要多加一个编译流程。但优点也是得到的数据最是全面。

这种方案也因为太过麻烦，所以业内用的人不多。

### 工具生成代码

写一个工具来自动完成。只要分析C++代码文件，或者分析编译器数据，然后用预定义好的规则生成相应的C++代码来跟源文件对应上。比如QT中的反射。

### UE里的UHT的方案

事先在C++源文件中空的宏做标记，然后用UHT分析生成generated.h/.cpp文件，之后再一起编译。

```C++
UCLASS()
class HELLO_API UMyClass : public UObject
{
    GENERATED_BODY()
public:
    UPROPERTY(BlueprintReadWrite, Category = "Test")
    float Score;

    UFUNCTION(BlueprintCallable, Category = "Test")
    void CallableFuncTest();

    UFUNCTION(BlueprintNativeEvent, Category = "Test")
    void NativeFuncTest();

    UFUNCTION(BlueprintImplementableEvent, Category = "Test")
    void ImplementableFuncTest();
};
```

优点是能够比较小的对C++代码做修改，所要做的只是在代码里加一些空标记，并没有破坏原来的类声明结构，而且能够以比较友好的方式把元数据和代码关联在一起，生成的代码再复杂也可以对用户隐藏起来。

一方面分析源码效果比较好的话，能够得到和编译器差不多的信息，还能通过自己的一些自定义标记来提供更多生成代码的指导。

缺点是实现起来其实也是挺困难的，完整的C++的语法分析往往是超级复杂的，所以限制是分析器只能分析一些简单的C++语法规则和宏标记，如果用户使用比较复杂的语法时候，比如用#if /#endif包裹一些声明，就会让自己的分析器出错了，还好这种情况不多。

关于多一次编译的问题，也可以通过自定义编译器的编译脚本UBT来规避。
